<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Framework Dilema | Minis</title>
    <meta name="description" content="Mini post: The Framework Dilema">
    <meta name="author" content="Beyond Me Btw">
    <meta property="og:title" content="The Framework Dilema">
    <meta property="og:type" content="article">
    <meta name="article:published_time" content="2026-01-13T11:19:00+05:30">
</head>
<body>
    
        <div class="markdown-content" style="
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: none;
        ">
            <style>
                .markdown-content h1 { font-size: 2em; margin: 0.67em 0; font-weight: bold; }
                .markdown-content h2 { font-size: 1.5em; margin: 0.75em 0; font-weight: bold; }
                .markdown-content h3 { font-size: 1.17em; margin: 0.83em 0; font-weight: bold; }
                .markdown-content p { margin: 1em 0; }
                .markdown-content ul, .markdown-content ol { margin: 1em 0; padding-left: 2em; }
                .markdown-content li { margin: 0.5em 0; }
                .markdown-content blockquote { 
                    margin: 1em 0; 
                    padding: 0.5em 1em; 
                    border-left: 4px solid #ddd; 
                    background: #f9f9f9; 
                    font-style: italic; 
                }
                .markdown-content code { 
                    background: #f4f4f4; 
                    padding: 0.2em 0.4em; 
                    border-radius: 3px; 
                    font-family: 'SF Mono', Monaco, monospace; 
                }
                .markdown-content pre { 
                    background: #f4f4f4; 
                    padding: 1em; 
                    border-radius: 6px; 
                    overflow-x: auto; 
                }
                .markdown-content pre code { 
                    background: none; 
                    padding: 0; 
                }
                .markdown-content a { 
                    color: #0066cc; 
                    text-decoration: none; 
                }
                .markdown-content a:hover { 
                    text-decoration: underline; 
                }
                .markdown-content img { 
                    max-width: 100%; 
                    height: auto; 
                    border-radius: 6px; 
                }
            </style>
            <p>I'm working on a project that involves running a YOLO model on the web using <strong>ONNX Runtime Web</strong>. On paper, it sounded straightforward: load the model, run inference, detect people. In practice, it turned into one of the most educational (and humbling) experiences I‚Äôve had so far.</p><p>I started the way I usually do with personal projects, dive in headfirst. I planned just enough to get moving, implemented things quickly, fixed errors as they came up, and tried to squeeze out as much performance as possible. This approach has always worked for me. And honestly, there‚Äôs nothing wrong with it.</p><p>But this project was different.</p><p>This wasn‚Äôt just about ‚Äúmaking it fast.‚Äù It was about understanding <strong>why it wasn‚Äôt fast</strong> and more importantly, how performance is actually measured and reasoned about in real-world software.</p><p><hr></p><p><h2>When Numbers Don‚Äôt Make Sense</h2></p><p>My initial inference time was around <strong>5000 ms</strong>. That‚Äôs bad. Detection lagged, the experience felt broken, and no amount of surface-level tweaking seemed to help. My instinct was to assume something was wrong with ONNX, the model, or even the browser.</p><p>That‚Äôs when I was taught something crucial. You map everything out. Every step. Every call. Every dependency.</p><p>That sounds obvious but it‚Äôs genuinely hard when you‚Äôve never worked on a client-facing project before. For the first time, I wasn‚Äôt just optimizing for myself. I was dealing with <strong>real constraints, real expectations, and real people</strong>. That pressure changes how you think.</p><p>Once I slowed down and actually mapped out the pipeline, things began to click. And honestly, I was more annoyed at myself than anything else because the answer was right there.</p><p><hr></p><p><h2>Vanilla JS vs Frameworks: The Real Difference</h2></p><p>To isolate the issue, I compared my implementation with another project running the <strong>same YOLOv12n model</strong>, doing the same task (person detection). That project used <strong>Next.js</strong>. Their inference time? Around <strong>150 ms</strong>.</p><p>Mine? Still stuck around <strong>1500 ms</strong>. The difference wasn‚Äôt the model.<br>It wasn‚Äôt ONNX. It wasn‚Äôt even the browser.</p><p>It was <strong>how things were loaded and orchestrated</strong>.</p><p>In my vanilla JavaScript setup, libraries were pulled in via CDN in a largely sequential manner. Scripts loaded step-by-step, dependencies resolved one after another, and the runtime paid the price.</p><p>Frameworks like Next.js, on the other hand, do a _lot_ of invisible work for you:</p><p>- Asynchronous and parallel loading of packages<br>- Smarter bundling and dependency resolution<br>- Optimized preprocessing pipelines<br>- Runtime optimizations that you don‚Äôt even think about until you miss them    </p><p>Once I understood this, the performance gap stopped feeling mysterious and started feeling inevitable.</p><p><hr></p><p><h2>What This Taught Me About Frameworks</h2></p><p>We throw around the word _framework_ all the time. ‚ÄúUse React.‚Äù ‚ÄúUse Next.‚Äù ‚ÄúFrameworks make things faster.‚Äù</p><p>But <strong>why</strong>? This project finally answered that for me.</p><p>Frameworks aren‚Äôt magic. They‚Äôre distilled experience. They encode years of lessons about loading strategies, execution order, caching, and runtime behavior things that are incredibly hard to get right on your own unless you‚Äôve already made every mistake once.</p><p>Once you understand _what_ a framework is actually doing for you, adapting to new tools becomes much easier. You stop treating them as black boxes and start seeing them as systems with advantages and trade-offs.</p><p><hr></p><p><h2>The Bigger Takeaway</h2></p><p>This experience taught me a lot about Development vs production thinking. About how you make something just to work vs making it reliable and more importantly it taught the consequences of optimizing blindy instead of with intent.   </p><p>It‚Äôs not the end of this project. But now I know it‚Äôs not about randomly optimizing or blaming the model. It‚Äôs about understanding the full pipeline: how things load, when they execute, and where time is actually spent.</p><p>Once that clicks, the problem stops feeling chaotic. Performance becomes something I can reason about, test systematically, and improve with intent.</p><p>To better understand everything end-to-end, I used <strong>NotebookLM</strong>, and it turned out to be genuinely enlightening.</p><p>If you‚Äôre curious, check it out here: üëâ <a href="https://notebooklm.google.com/notebook/ee800966-4605-4691-8492-79f27bc89f7c" target="_blank" rel="noopener noreferrer">NotebookLM</a></p>
        </div>
</body>
</html>